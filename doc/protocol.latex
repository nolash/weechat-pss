\documentclass[a4paper, 10pt]{article}
\usepackage{glossaries}
\usepackage{colortbl}
\usepackage{tcolorbox}

\newcommand{\bzctrl}[1]{$C_{#1}$}
\newcommand{\bzkey}[2]{$P_{#1}#2$}
\newcommand{\bzpubkey}[2]{$P_{#1}#2_{pub}$}
\newcommand{\bzprivkey}[2]{$P_{#1}#2_{priv}$}
\newcommand{\bzaddrkey}[2]{$P_{#1}#2_{addr}$}
\newcommand{\bzsymkey}[2]{$S_{#1}#2$}
\newcommand{\bzhash}[1]{HASH$_{#1}$}
\newcommand{\bzroom}[1]{R$_{#1}$name}
\newcommand{\bzfeedserial}[3]{R$_{#1}$T$_{#2}$#3}
\newcommand{\bzaxx}[3]{R$_#1X_#2$#3}
\newcommand{\bzfeedtopic}[1]{T$_{#1}$}

\loadglsentries{protocol_glossary}

\author{lash}
\title{Subjectively rendered multiuser chat rooms}

\begin{document}
\date{\today\\ v0.5.0 alpha}

\section{Overview}

This is an attempt to describe a system for decentralized multiuser chat rooms with strong privacy guarantees for both the contents of messages being exchanged (data) aswell as who are communicating with whom (metadata).

By saying Swarmchat is decentralized we mean two things. Firstly, it inherits the decentralized properties of the data storage layer of Swarm itself. Secondly, the individual clients send data to the chats by maintaining individual data feeds. In turn, they are themselves responsible for rendering the state of the chats by retrieving the data from all feeds that make up respective chats.

The privacy properties are also twofold.
For content protection we do not seek to favor any particular flavor of message encryption scheme. \gls{swarmchat} is however designed with ephemeral key derivation schemes like axolotl \cite{WPSIGNAL:1} in mind, or more specifically allowing sequential exchange of key material between peers. 
To protect metadata we suggest \emph{band-change} mechanisms that makes it possible to change a client's "address" on the network at will. 

Although this document builds on technology provided by the Ethereum Swarm project, we hope to outline concepts that can be implemented on any technology that provides the same main components.

For simplicity we'll use the word \emph{\gls{swarmchat}} for what we're describing as we go forward. 

\subsection{Core concepts}

\subsection{Conventions used in this document}

\section{About Swarm}

\subsection{Storage}

\subsection{Messaging (PSS)}

\subsection{Mutable resources (feeds)} \label{sec:bzz-feeds}

\section{Components}

In our approach, all updates changing the state of a chat are performed using a \emph{pull} model. Only peer connectivity and update notifications are sent using \emph{push} messages.

\subsection{Identities}

Identities in \gls{swarmchat} are defined by a combination of independently generated \glspl{ethpublickey}.

\subsubsection{\gls{idkey}}

When a new user wants to connect to its first peer in the \gls{swarmchat} network for the first time, a \gls{idkey} must be used. \gls{swarmchat} does \emph{not} provide mechanisms for discovery of the \glspl{idkey} themselves, nor the mapping them to other entities.

The \gls{idkey} is used to ask the peer client for the \gls{sessionkey} (\ref{sec:sessionkey}) it is currently using. It may be changed, but there is no mechanism in \gls{swarmchat} to notify peers about this change, so this must be done out-of-band.

We refer to the \gls{idkey} as follows:

\begin{description}
\item [Public key] \bzpubkey{id}{user} 
\end{description}

\subsubsection{\gls{sessionkey}} \label{sec:sessionkey}

The \gls{sessionkey} is randomly generated and used to secure and identify its \glspl{swarmfeed}. It may be changed at any time. When it is changed, all the user's peers are notified of the new key. Since it randomly changes, and only peers know the changed key, it is hard for outsiders to guess where to look for future updates. The derived \gls{ethaddress} of the \gls{sessionkey} makes up the \gls{updateaddress}. We refer to the \gls{sessionkey} as follows:

\begin{description}
\item [Key pair] \bzkey{ses_n}{user}
\item [Private key] \bzprivkey{ses_n}{user} 
\item [Public key] \bzpubkey{ses_n}{user} 
\item [Ethereum address] \bzaddrkey{ses_n}{user} 
\end{description}

\subsubsection{\gls{locationkey}}

The \gls{locationkey} is the \gls{ethpublickey} of a \gls{pss} node where the user is currently receiving messages. The node - and thus the \gls{locationkey} - may be changed at any time. The \gls{locationkey} together with the \gls{swarmaddress} of the \gls{pss} node makes up the \gls{locationaddress}. When this is changed, all the user's peers must be notified of the new one. We refer to the \gls{locationkey} as follows:

\begin{description}
\item [Public key] \bzpubkey{loc_n}{user} 
\end{description}
 
\subsection{Shared secrets}

Shared secrets in this context means keys used to encrypt \gls{swarmchat} content, aswell as data used to derive such keys. In our scope we handle three such secrets.

Specifics regarding transmission and generation of these secrets is out of scope of this document.

\subsubsection{\gls{headerkey}}
Encrypts the part of the message containing sequential exchange of key material.

\bzsymkey{head}{user}

\subsubsection{\gls{datakey}}

Encrypts \gls{swarmfeed} update contents.

\bzsymkey{data}{user} 

\subsubsection{\gls{msgkey}}

Encrypts \gls{pss} message contents. 

\bzsymkey{msg}{user} 


\subsection{Connections}

A \gls{swarmchat} connection consists of two things. First an exchange of \glspl{sessionkey}. Then the creation or continuation of the respective \gls{singleuserchat} \glspl{swarmfeed}.

The connection is initiated with the connecting user $A$ sending its \gls{sessionkey} to the peer $B$ in a \gls{pss} session message.

If the \gls{locationaddress} of $B$ is unknown, the message is sent without \gls{swarmaddress}, encrypted with the \bzpubkey{id}{B}. Otherwise the corresponding \gls{swarmaddress} and \bzpubkey{ses_n}{B} may be used.

When $B$ receives the message (and wishes to accept the connection), it will create and update its \gls{singleuserchat} using the \gls{ethpublickey} corresponding to the private key it used to decrypt the message (in out example either \bzpubkey{id}{B} or \bzpubkey{ses_n}{B}). That \gls{swarmfeed} will contain updates that provide the \gls{updateaddress} and \gls{locationaddress} $B$ currently uses.

$A$ then reads the \gls{singleuserchat} \gls{swarmfeed} from $B$, and provides its \gls{locationaddress} in a subsequent update.

Lastly $B$ reads this feed and records the \gls{locationaddress}, and the connection is defined as completed.

See \ref{sec:apx-pss-session} for message structure.

\subsection{Discovery}

A user wishing to participate in a \gls{multiuserchat} cannot determine the \gls{locationaddress} of individual participants from the \gls{participantlist}. That means there is no immediate way of \emph{connecting} to the peers in the \gls{chatroom}. Therefore we must define a mechanism to query \emph{already connected peers} about the \glspl{locationaddress} of those peers.

For example, \bzroom{n} has participants $A$ and $C$. $B$ wants to participate, and knows the \bzpubkey{loc_i}{A}, but does not know \bzpubkey{loc_j}{C}. However, from the \gls{participantlist} $B$ \emph{does} know \bzpubkey{ses_j}{C}. $B$ should now use \bzpubkey{ses_j}{C} to ask $A$ about the \bzpubkey{loc_j}{C}. Of course, it is the discretion if $A$ to comply. Aswell as it is in turn the discretion of $C$ to accept the subsequent connection attempt from $B$.

Remember that \gls{swarmchat} does \emph{not} provide discovery of \glspl{idkey}. Identifying the initial participant peer in a \gls{multiuserchat} must be handled externally\footnote{One obvious solution here is to define an on-chain resource which can map ENS names to one or more \glspl{idkey} to room topics.}.

See \ref{sec:updates-id} for further details.

\subsection{Topics}

When we use the term \emph{topic} in the context \gls{swarmchat} we are referring to the 32-byte \gls{swarmfeed} topic.

Every user in \gls{swarmchat} maintains a collection of \glspl{swarmfeed} that serve specific purposes in transmitting content and changing the state of chats. We use strongly defined topics to distinguish between them. These are in turn are merged with other identifiers to obtain more fine-grained definitions.

The base topic for \gls{swarmchat} is referred to as \bzfeedtopic{root}.

\subsubsection{\gls{singleuserchat}}

If the last bit of the topic is 0 it is defined as a \gls{singleuserchat}. We refer to this topic as \bzfeedtopic{single}.
By performing \emph{left-aligned xor} on the topic with the \gls{sessionkey} belonging to $peer$ we define the update feed for the \gls{singleuserchat} for the recipient $peer$:

\bzfeedtopic{single} $\oplus$ \bzaddrkey{s_n}{peer}

\subsubsection{\gls{multiuserchat}}

If the last bit of the topic is 1 it is defined as a \gls{multiuserchat}. We refer to this topic as \bzfeedtopic{room}.

By performing \emph{left-aligned xor} on the topic with a \gls{roomname} we define the chatroom context for that name:

\bzfeedtopic{room} $\oplus$ \bzroom{n}

A user always maintains two \glspl{swarmfeed} for a \gls{multiuserchat}.

If the penultimate bit in \bzfeedtopic{room} is 0 it defines the \gls{updatefeed} (\ref{sec:feeds-updatefeed}):

\bzfeedtopic{room} $\oplus$ \bzroom{n} $\oplus$ \bzfeedtopic{data}

If it is 1 it defines the \gls{participantfeed} (\ref{sec:feeds-participantfeed}):

\bzfeedtopic{room} $\oplus$ \bzroom{n} $\oplus$ \bzfeedtopic{meta}

A \gls{roomname} may be a maximum of 31 bytes long.

\subsection{Feeds}

Chat updates (\emph{pull}) are linked lists of immutable data entities, represented by \gls{contentaddressed} identifiers. Clients maintain \glspl{swarmfeed} as pointers to the \gls{contenthash} representing the current \emph{head} of this chain of updates.

The integrity of a \glspl{swarmfeed} on the network is ensured with signatures using \glspl{sessionkey} generated by the sender. This \gls{sessionkey} together with the \gls{feedtopic} defines where the \gls{swarmfeed} predictably can be found on the network. In our context this predictable identifier is called \gls{updateaddress}.

\subsubsection{\gls{singleuserchat}} \label{sec:feeds-singleuserchat}

Any two users that are connected in \gls{swarmchat} will maintain a \gls{singleuserchat} between them.

Let's say users $A$ and $B$ are connected. In this example $i$ and $j$ are the current serial number of respective peers' \glspl{sessionkey}, and the parameters to $Feed()$ are:

\begin{enumerate}
\item sender's \gls{sessionkey}
\item the \gls{swarmfeed} topic
\end{enumerate}

We can then describe the \glspl{swarmfeed} for these chats as follows:

\begin{itemize}
	\item A's feed
	\begin{itemize}
		\item Feed(\bzaddrkey{s_i}{A}, \bzfeedtopic{single} $\oplus$ \bzaddrkey{s_j}{B})
	\end{itemize}
	\item B's feed
	\begin{itemize}
		\item Feed(\bzaddrkey{s_j}{B}, \bzfeedtopic{single} $\oplus$ \bzaddrkey{s_i}{A})
	\end{itemize}
\end{itemize}

\subsubsection{\gls{multiuserchat}} \label{sec:feeds-participantfeed} \label{sec:feeds-updatefeed}

A user sending updates to a \gls{chatroom} always maintains two feeds, the \gls{participantfeed} and the \gls{updatefeed}.

The \gls{participantfeed} is the user's \emph{subjective opinion} of who the participants in the \gls{multiuserchat} are, and what privileges \footnote{Keep in mind that \gls{swarmchat} aims to be fully decentralized, which means that no central authority exists that decides what the "true" participant list is. Instead, the peers have to somehow find a way to agree on it. Meanwhile, matters of access control (beyond defining the data field for it) and protocols for reaching privilege consensus is outside the scope of this document.} they have there.

Following the example in \ref{sec:feeds-singleuserchat} of users $A$ and $B$ participating in the same \gls{multiuserchat} named "kazbah," the feeds they maintain are described as:

\begin{itemize}
	\item A's feeds
	\begin{itemize}  
		\item Feed(\bzaddrkey{s_i}{A}, \bzfeedtopic{room} $\oplus$ \bzfeedtopic{meta} $\oplus$ \bzroom{kazbah})
		\item Feed(\bzaddrkey{s_i}{A}, \bzfeedtopic{room} $\oplus$ \bzfeedtopic{data} $\oplus$ \bzroom{kazbah})
	\end{itemize}
	\item B's feeds
	\begin{itemize} 
		\item Feed(\bzaddrkey{s_i}{B}, \bzfeedtopic{room} $\oplus$ \bzfeedtopic{meta} $\oplus$ \bzroom{kazbah})
		\item Feed(\bzaddrkey{s_i}{B}, \bzfeedtopic{room} $\oplus$ \bzfeedtopic{data} $\oplus$ \bzroom{kazbah})
	\end{itemize}
\end{itemize}

\subsection{Updates}

By \emph{updates} we mean data that either are to be consumed for the end-user, or state changes in the \gls{chatroom} the update belongs to, along with necessary metadata. The actual data \emph{less} the metadata we refer to as \emph{\gls{updatepayload}}.

We will now examine which type of updates exist for each type of \gls{swarmfeed} in \gls{swarmchat}, what they may contain, and what responses that can be expected from them, if any.

\subsubsection{Data updates} \label{sec:updates-data}

\gls{swarmchat} structures a chat as a linked list of updates, where a single update is content referenced by a \gls{swarmhash}. The \gls{updatefeed} must always point to the newest \gls{swarmhash} in this list.

Common for both \glspl{singleuserchat} and \glspl{multiuserchat} is that each update contains the \gls{swarmhash} of the previous update. If the update is the first update for the chat, the \gls{zeroaddress} is referenced instead.

Also common is an update serial number made up of a 4-byte Unix timestamp, concatenated with a 1 byte serial number only used if the previous update was made within the same second \footnote{The timestamp and serial number is defined by the sender, and there is no way for the receiver of the update to verify if it is correct or not, outside of disallowing timestamps in the future, or timestamps that precede the previous one. That being said, handling timestamp integrity is out of scope of this document}.

\subsubsection{\gls{singleuserchat}}

The \gls{updatepayload} follows immediately after the above. The payload must be encrypted using \bzsymkey{data_n}{peer}.

See \ref{sec:apx-single} for update data structure.

\subsubsection{\gls{multiuserchat}}

Some additional fields are required for the \gls{multiuserchat} to correctly represent the context of the update.

Following where we left off in \ref{sec:updates-data}, the \gls{swarmhash} of the \gls{participantlist} at the time of the update must be added. 

Then concatenate the length as a \emph{little-endian 4-byte unsigned int} of an encrypted \glspl{updatepayload} \footnote{We assume that the length of the ciphertext will be the same regardless of which \gls{roomparticipant} key is used}.

To complete, the individually encrypted \glspl{updatepayload} for every \gls{roomparticipant} are included \emph{in the same order as the referenced \gls{participantlist}}.

See \ref{sec:apx-room} for update data structure.

\subsubsection{\gls{participantlist}}

Participantlists are of course only relevant in the context of \glspl{multiuserchat}, and are as previously stated \emph{subjective} (see \ref{sec:feeds-participantfeed}).

Furthermore, the historical \glspl{participantlist} are only relevant in context with concrete updates, and also referenced from each individual one, they can be mere standalone updates. The \gls{participantfeed} should always point to the latest update.

The first item in this data structure is the verbatim room name prefixed with a one-byte value giving the length of the room name. 

Then follows the \gls{axxdef} the sender claims to have in the \gls{chatroom}.

The structure is concluded with a list of pairs of \glspl{sessionkey} and \glspl{axxdef} for each \gls{roomparticipant}.

See \ref{sec:apx-participants} for update data structure.

\subsection{\glspl{payload}}

Encapsulating the actual data content in an update, \glspl{payload} are common for both \glspl{singleuserchat} and \glspl{multiuserchat}. Several different types of payloads are defined.

A payload is divided into a \emph{header} and a \emph{body}.

The \emph{header} is reserved for exchange of cryptographic key material and must be encrypted using \bzsymkey{meta_n}{peer}. Any detail on key negotiations using this field is out of scope of this document.

The \emph{body} must be encrypted using \bzsymkey{data_n}{peer}. 

The first data field in a \gls{payload} \emph{body} is always the \gls{payloadid}.
We will now go through the different \gls{payload} types in sequence.

\subsubsection{content}

Defines content to be consumed by the end-user, and is merely comprised of the data itself. \footnote{The data may of course encapsulate a different protocol. See \ref{sec:future} for some thoughts on this subject}.

We refer to the content \gls{payloadid} as \bzctrl{content}

See \ref{sec:apx-content} for update data structure.

\subsubsection{flow control}

We can use the \bzctrl{start} and \bzctrl{stop} identifiers to define the start or the end of an update chain. We also define the \bzctrl{mark} identifier, which is a "no-op" update used for example in a ping request notification (see \ref{sec:notify-ping})

Typically, \bzctrl{start} will be used as the first update in a room, so peer requests for its \gls{swarmfeed} do not time out (see \ref{sec:bzz-feeds}).

The \bzctrl{end} marker is used to terminate an update chain after a change of \gls{updateaddress}, or to explicitly \emph{disconnect} a peer.

All \gls{payload} types contain the \gls{feedserial} of the \emph{update of the peer} the change is applicable from. If the context is a room, the \gls{roomname} must also be specified.

See \ref{sec:apx-flow} for update data structure.

\subsubsection{\gls{updateaddress} change}

Contains the new \gls{sessionkey} to be used to for the peer \glspl{swarmfeed}. The old \gls{sessionkey} should be kept until a \bzctrl{stop} is found on that feed and subsequently discarded\footnote{If \bzctrl{stop} is not issued the feeds are still kept alive after an \gls{updateaddress} change. One possible use of this could be keeping several feeds and using them for obfuscation purposes in a round-robin or randomly switched fashion, without suffering the overhead of establishing new feeds for every switch}. The peer must not make new updates to the \glspl{swarmfeed} with the old \gls{sessionkey} after the \bzctrl{stop} payload is sent.

See \ref{sec:apx-updaddr} for update data structure.

\subsubsection{\gls{locationaddress} change}

Contains the new \gls{locationaddress} (\gls{locationkey} and \gls{swarmaddress}) to be used to send pss notifications to the peer. The old \gls{locationaddress} should be discarded immediately. The peer should listen on both \glspl{locationaddress} until a message is received on the new one.

See \ref{sec:apx-locaddr} for update data structure.

\subsubsection{Preferences} 

Enables a user to request certain behavior from its peer, for example under what conditions and in which form to send notifications.

It contains a \gls{swarmhash} reference to a data structure describing those preferences (see \ref{sec:updates-prefs}).

\subsubsection{\gls{relay}}

\gls{relay} in our model occurs when a user provides a \gls{digest} of a collection of updates in one single update. The relay type contains a \gls{swarmhash} that references the collection. A user may also reference updates from other users (see \ref{sec:updates-digest})

\emph{\gls{relay} should only be valid in \gls{singleuserchat} context}

\subsection{Notifications} 

Notifications enable peers to alert each other explicitly about new content or states. Notification messages must be encrypted using \bzsymkey{msg_n}{peer}.

The user can define which conditions these notifications should occur. In turn, the peer will inform the user whether it accepts or rejects these conditions (see \ref{sec:updates-prefs}).

The data of a notification message with type \bzctrl{notify} contains the topic of the \gls{swarmfeed} that should be checked for a new update\footnote{Notice how the design allows us to send a notification of an update in a \gls{singleuserchat} where this update in turn is a \gls{relay} pointing to a \gls{digest} of updates}, the \gls{feedserial} of the update, and a signature on the concatenation of the above. The \gls{sessionkey} of the sender is derived from the signature.

A peer $A$ notifying peer $B$ of an update in its \gls{singleuserchat} \gls{swarmfeed}:

$SIGN\{$\bzprivkey{ses_n}{A}$\}($\bzfeedtopic{single} $\|$ \bzfeedserial{kazbah}{i}{B}$)$

Similarly, notifying about an update its room "kazbah" thus provides this signature:

$SIGN\{$\bzprivkey{ses_n}{A}$\}($\bzfeedtopic{room} $\oplus$ \bzfeedtopic{data} $\oplus$ \bzroom{kazbah} $\|$ \bzfeedserial{kazbah}{i}{B}$)$

See \ref{sec:apx-pss-notify} for details on message structure.

\subsubsection{Embedding data}

Notifications normally reference content already in \gls{swarm}. Such a notification will be of type \bzctrl{notify}. But may also include the content itself within the notification\footnote{\gls{pss} messages should have size constraints by convention. TODO refer to pss paper where this is specified}. In this case the notification will be of type \bzctrl{notifydata}.

It is possible to include custom data with a notification message of type \bzctrl{notify} in the trailing \emph{data} field. However, if the notification is of type \bzctrl{notifydata}, the data field must instead contain a copy of the updatedata being referenced by the \gls{swarmfeed} topic.

\subsubsection{Ping} \label{sec:notify-ping}

A user may use the notification to check if the peer is currently online. This is done by setting the topic field to \bzfeedtopic{root}. Upon receipt, the peer should in turn update the \gls{singleuserchat} appropriately.

In this case, the peer should not issue a notification when making the update.

\subsection{Preferences} \label{sec:updates-prefs}

Although we define a preferences payload type, it is out of scope for this document to go into detail about the structure of this data or how it should be interpreted.

That said, the initial motivation for enabling preferences to be set is to make it possible to specify parameters for notification behavior.

\subsubsection{Digest} \label{sec:updates-digest}

A digest simply encapsulates a collection of update payloads associated with the source (updateaddress) of the specificied payload. This a digest may also contain updates from other users, enabling users to serve as feed aggregators.

Issues involving aggregation, including but not limited to generation, trust and data availability, is beyond the scope of this document. We will also not give a protocol example using digest below.

\subsection{Identification} \label{sec:updates-id}

TODO: Define structure of \gls{sessionkey} requests for third-party peers.

\section{Cryptography}

As mentioned earlier in this document we don't prefer any particular encryption scheme for \gls{swarmchat} content. That being said, we find it advisable to choose a scheme that enables continual regeneration of all shared secrets in a way that provides forward and backward secrecy.

\section{Protocol}

In the following sections we will demonstrate actual protocol exchanges, and the changes in state that these exchanges cause.

\subsection{Connecting}

\subsubsection{Unknown session key}

\subsubsection{Known session key}

\subsubsection{Ending sessions}

\subsection{Direct messages}

\subsection{Multiuser rooms}

\subsubsection{Invite new peer to room}

\subsubsection{Request to join room}

\subsubsection{Access control}

\subsection{Managing identities}

\subsubsection{Query identity}

\subsubsection{Update address change}

\subsubsection{Location address change}

\section{Notes on performance}

\subsection{Feed creation}

\section{Attacks}

\subsection{Metadata from PSS topic}

\subsection{Fake notifications}

\section{Further concepts} \label{sec:future}

\newpage

\appendix
\section{Data formats}

Data fields are listed sequentially for each structure.

Update feeds are denoted as rooms, prefixed with $R$. A direct message feed is defined as $R_0$.

\subsection{constants}

\begin{description}
	\item[\bzctrl{session}] TODO
	\item[\bzctrl{notify}] TODO
	\item[\bzctrl{notifydata}] TODO
	\item[\bzctrl{band}] TODO
	\item[\bzctrl{locaddr}] TODO
	\item[\bzctrl{updaddr}] TODO
	\item[\bzctrl{prefs}] TODO
	\item[\bzctrl{start}] TODO
	\item[\bzctrl{end}] TODO
	\item[\bzctrl{mark}] TODO
	\item[\bzctrl{id}] TODO
	\item[\bzctrl{relay}] TODO
\end{description}


\subsection{PSS messages}

\subsubsection{session} \label{sec:apx-pss-session}

\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{lightgray} \textbf{field} & \textbf{size} & \textbf{identifier} & \textbf{encryption} \\
\hline
\gls{proofofcost} & ? & (implementation dependent) & - \\
\gls{payloadid} & 2 & \bzctrl{session} & \bzpubkey{id}{X} \\
\gls{sessionkey} & 32 & \bzpubkey{ses_n}{user} & \bzpubkey{id}{X} \\
Shared seed secret & ? & \bzsymkey{seed}{peer} & \bzpubkey{id}{X} \\
\hline
\end{tabular}

\subsubsection{notify} \label{sec:apx-pss-notify}

\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{lightgray} \textbf{field} & \textbf{size} & \textbf{identifier} & \textbf{encryption} \\
\gls{payloadid} & 2 & \bzctrl{notify} $\lor$ \bzctrl{notifydata} & \bzsymkey{msg_n}{peer} \\
\gls{feedtopic} & 32 & \bzfeedtopic{root} $\oplus$ \dots & \bzsymkey{msg_n}{peer} \\
\gls{feedserial} & 5 & \bzfeedserial{n}{i}{peer} & \bzsymkey{msg_n}{peer} \\
Signature & 32 & $SIGN\{$\bzprivkey{ses_n}{user}$\}($\gls{feedtopic} $\|$ \bzfeedserial{n}{i}{peer}$)$ & \bzsymkey{msg_n}{peer} \\
(custom) data & var & \bzctrl{notify}: implementation dependent & \bzsymkey{msg_n}{peer} \\
& & \bzctrl{notifydata}: copy of actual payload & \\
\hline
\end{tabular}

\subsection{Feed entries}

\subsubsection{participantlist} \label{sec:apx-participants}

\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{lightgray} \textbf{field} & \textbf{size} & \textbf{identifier} & \textbf{encryption} \\
\gls{roomname} & var & \bzroom{n} & - \\
\gls{axxdef} & ? & \bzaxx{n}{i}{user} & - \\ 
Participants & [] & \bzpubkey{s_n}{peer} & - \\
 & & \bzaxx{n}{i}{peer} & \\
\hline
\end{tabular}


\subsubsection{\gls{singleuserchat} update} \label{sec:apx-single}

\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{lightgray} \textbf{field} & \textbf{size} & \textbf{identifier} & \textbf{encryption} \\
Previous update & 32 & \bzhash{bzz}{previousupdate} & - \\
\gls{feedserial} & 5 & \bzfeedserial{n}{i}{user} & - \\
\glspl{payload} & payload (\ref{sec:apx-payload}) & \bzsymkey{data_n}{peer} \\
\hline
\end{tabular}


\subsubsection{\gls{multiuserchat} update} \label{sec:apx-room}

\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{lightgray} \textbf{field} & \textbf{size} & \textbf{identifier} & \textbf{encryption} \\
Previous update & 32 & \bzhash{bzz}{previousupdate} & - \\
\gls{feedserial} & 5 & \bzfeedserial{n}{i}{user} & - \\
\gls{participantlist} & 32 & \bzhash{bzz}{participantlist} & - \\
Single ciphertext length & 4 & Little-endian unsigned & - \\
\glspl{payload} & [] & payload (\ref{sec:apx-payload}) & \bzsymkey{data_n}{peer} \\
\hline
\end{tabular}


\subsection{Payloads} \label{sec:apx-payload}

\subsubsection{content} \label{sec:apx-content}

\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{lightgray} \textbf{field} & \textbf{size} & \textbf{identifier} & \textbf{encryption} \\
encryption header & ? & (implementation dependent) & \bzsymkey{meta_n}{peer} \\
\gls{payloadid} & 2 & \bzctrl{content} & \bzsymkey{data_n}{peer} \\
Data & var & \ldots & \bzsymkey{data_n}{peer} \\
\hline
\end{tabular}

\subsubsection{location address change} \label{sec:apx-locaddr}

\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{lightgray} \textbf{field} & \textbf{size} & \textbf{identifier} & \textbf{encryption} \\
encryption header & ? & (implementation dependent) & \bzsymkey{meta_n}{peer} \\
\gls{payloadid} & 2 & \bzctrl{locaddr} & \bzsymkey{data_n}{peer} \\
Pss node public key & 65 & \bzpubkey{loc_n}{user} & \bzsymkey{data_n}{peer} \\
Pss node \gls{swarmaddress} & 0-32 & \ldots & \bzsymkey{data_n}{peer} \\
\hline
\end{tabular}

\subsubsection{update address change} \label{sec:apx-updaddr}

\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{lightgray} \textbf{field} & \textbf{size} & \textbf{identifier} & \textbf{encryption} \\
encryption header & ? & (implementation dependent) & \bzsymkey{meta_n}{peer} \\
\gls{payloadid} & 2 & \bzctrl{updaddr} & \bzsymkey{data_n}{peer} \\
\gls{updateaddress} & 65 & \bzpubkey{ses_{n+1}}{user} & \bzsymkey{data_n}{peer} \\
\hline
\end{tabular}

\subsubsection{flow control} \label{sec:apx-flow}
\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{lightgray} \textbf{field} & \textbf{size} & \textbf{identifier} & \textbf{encryption} \\
encryption header & ? & (implementation dependent) & \bzsymkey{meta_n}{peer} \\
\gls{payloadid} & 2 & \bzctrl{start} $\lor$ \bzctrl{end} $\lor$ \bzctrl{mark} & \bzsymkey{data_n}{peer} \\
\gls{feedserial} & 5 & \bzfeedserial{n}{i}{peer} & \bzsymkey{data_n}{peer} \\
\hline
\end{tabular}

\bibliographystyle{plain}
\bibliography{protocol}

\end{document}
